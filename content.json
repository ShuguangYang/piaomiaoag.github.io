{"meta":{"title":"飘渺阿光","subtitle":"阿光的博客","description":"秃头码农","author":"飘渺阿光","url":"http://shuguangyang.github.io","root":"/"},"pages":[{"title":"404","date":"2019-05-11T05:54:31.000Z","updated":"2019-05-11T05:54:31.353Z","comments":true,"path":"404/index.html","permalink":"http://shuguangyang.github.io/404/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-05-15T13:02:04.000Z","updated":"2019-05-15T13:04:07.627Z","comments":true,"path":"about/index.html","permalink":"http://shuguangyang.github.io/about/index.html","excerpt":"","text":"QQ： 437012461微信： yang437012461学校： 电子科技大学"},{"title":"分类","date":"2019-05-15T12:56:38.000Z","updated":"2019-05-15T13:00:47.236Z","comments":true,"path":"categories/index.html","permalink":"http://shuguangyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2019-05-11T05:54:21.000Z","updated":"2019-05-11T05:54:21.502Z","comments":true,"path":"search/index.html","permalink":"http://shuguangyang.github.io/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-15T12:58:08.000Z","updated":"2019-05-15T13:00:56.991Z","comments":true,"path":"tags/index.html","permalink":"http://shuguangyang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用github搭建自己的博客","slug":"利用github搭建自己的博客","date":"2019-05-15T08:12:45.000Z","updated":"2019-05-15T12:21:11.193Z","comments":true,"path":"2019/05/15/利用github搭建自己的博客/","link":"","permalink":"http://shuguangyang.github.io/2019/05/15/利用github搭建自己的博客/","excerpt":"1.环境配置 安装node.js。 安装GitForWindows，没有的同学在这一部还要注册github。 安装Hexo。打开命令终端，输入npm install -g hexo-cli安装，安装完成后，检查是否成功hexo version。 使用hexo初始化一个项目，选择一个文件夹，用来存放博客项目。之后会弹出一个git命令窗口，输入hexo init 你自己的项目名称（我的是MyBlog），运行结束后会出现自己的项目文件夹，然后输入cd 你自己的项目名称进入到该项目文件目录下，最后输入npm install命令。","text":"1.环境配置 安装node.js。 安装GitForWindows，没有的同学在这一部还要注册github。 安装Hexo。打开命令终端，输入npm install -g hexo-cli安装，安装完成后，检查是否成功hexo version。 使用hexo初始化一个项目，选择一个文件夹，用来存放博客项目。之后会弹出一个git命令窗口，输入hexo init 你自己的项目名称（我的是MyBlog），运行结束后会出现自己的项目文件夹，然后输入cd 你自己的项目名称进入到该项目文件目录下，最后输入npm install命令。 2.创建项目 在上述git窗口继续执行命令hexo g，以后每次更新博客都需要执行此命令。 接下来执行hexo s，打开http://localhost:4000/查看结果。 页面可以访问，并且显示首页，博客项目就已经创建好了。3.部署到github 登陆github账号创建一个新的仓库。 创建格式必须为用户名.github.io。 创建好以后进入设置界面，滑动到仓库设置界面的最底部，找到“GitHub Pages”选项，点击“Choose a theme”。 选择一个主题，应用即可，这里用Chrome浏览器设置，其他浏览器可能还会有问题。 在git窗口执行命令ssh-keygen,一路回车确定，执行完毕后，会在 “ c://Users/用户名/.ssh 文件夹下 ”生成两个文件，分别是： id_rsa 和 id_rsa.pub。 用记事本打开 idrsa.pub 文件，复制里面的所有内容。打开 github，点击设置，进入SSH and GPG keys页面。点击 NEW SSH key 进入SSH key添加界面。其中：title任意填，key填入刚刚我们复制的id_rsa.pub的内容，最后点击 Add SSH key 完成添加。 进入项目文件夹，找到“ _config.yml ” 配置文件，在文件最后找到deploy,修改代码。(注意，冒号后面要加空格) deploy: type: git repo: git@github.com:ShuguangYangshugangyang.github.io.git branch: master 在gitbash命令终端，执行命令hexo d -g,提示输入密码的话，直接回车。 最后访问网址：https://你的GitHub用户名.github.io 就可以看到我们的网址啦！","categories":[{"name":"hexo","slug":"hexo","permalink":"http://shuguangyang.github.io/categories/hexo/"}],"tags":[{"name":"web","slug":"web","permalink":"http://shuguangyang.github.io/tags/web/"}]},{"title":"Java的垃圾回收机制","slug":"Java的垃圾回收机制","date":"2019-04-15T13:18:09.000Z","updated":"2019-05-15T13:54:06.199Z","comments":true,"path":"2019/04/15/Java的垃圾回收机制/","link":"","permalink":"http://shuguangyang.github.io/2019/04/15/Java的垃圾回收机制/","excerpt":"","text":"Java的垃圾回收机制 Java的垃圾回收机制，使得Java程序员在编写程序的时候不再考虑内存管理。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡或者长时间没有使用的对象进行清除和回收。 垃圾回收涉及到两种做法：引用计数法和可达性分析算法。这里还涉及到java的4种引用方式：强引用，软引用，弱引用和虚引用。其中引用强度越来越低，也就意味着引用弱的对象越容易被垃圾回收。JVM的内存模型 Java程序内存的分配是在JVM虚拟机内存分配机制下完成，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。Java数据区域分为五大数据区域。这些区域各有各的用途，创建及销毁时间。其中方法区和堆是所有线程共享的，栈，本地方法栈和程序虚拟机则为线程私有的。程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。 Java利用多线程机制使得多个任务能够同时执行处理，所有的线程共享JVM内存区域，而且每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理。分代的垃圾回收策略 新生代（Young Generation）。所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集那些生命周期短的对象。新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。NewSize和MaxNewSize分别可以控制新生代的初始大小和最大的大小。 老年代（Old Generation）。在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 持久代（Permanent Generation）。用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。","categories":[{"name":"java","slug":"java","permalink":"http://shuguangyang.github.io/categories/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://shuguangyang.github.io/tags/jvm/"}]},{"title":"开启新的篇章","slug":"开启新的篇章","date":"2018-06-29T04:05:21.000Z","updated":"2019-05-15T12:53:41.546Z","comments":true,"path":"2018/06/29/开启新的篇章/","link":"","permalink":"http://shuguangyang.github.io/2018/06/29/开启新的篇章/","excerpt":"","text":"以后要记录所有新学到的知识点开启一段新的学习方法","categories":[{"name":"生活","slug":"生活","permalink":"http://shuguangyang.github.io/categories/生活/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://shuguangyang.github.io/tags/日记/"},{"name":"记叙","slug":"记叙","permalink":"http://shuguangyang.github.io/tags/记叙/"}]}]}