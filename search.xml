<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面经记录</title>
      <link href="/2019/06/09/Java%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/09/Java%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>#Java如何进行异常处理#<br>java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并且提供了良好的接口。通过5个关键词：try、catch、throw、throws和finally来实现异常处理。每个异常都是一个对象，它是Throwable类或其他子类的实例。其中try用来执行一段程序，如果出现异常，系统就是抛出一个异常，catch通过异常类型来捕捉它，throw语句用来明确抛出一个异常，throws用来标明一个成员函数可能抛出的各种“异常”，finally是不管发生什么异常都会被执行的一段代码。</p><p>#Static Nested Class和Inner Class的区别#<br>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Static-Nested Class 的成员，既可以定义为静态的(static)，也可以定义为动态的(instance)。Nested Class的静态成员(Method)只能对Outer Class的静态成员(static memebr)进行操作(ACCESS)，而不能Access Outer Class的动态成员(instance member)。而 Nested Class的动态成员(instance method) 却可以 Access Outer Class的所有成员，这个概念很重要，许多人对这个概念模糊。有一个普通的原则， 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS)， 而动态方法( (instance method) 总是跟 instance object 相关联, 所以，静态方法(static method)永远不可以Access跟 object 相关的动态成员(instance member)，反过来就可以，一个CLASS的 instance object 可以 Access 这个 Class 的任何成员，包括静态成员(static member)。</p><p>#abstract class和interface的区别#<br>抽象类（abstract class）就是声明方法的存在而不去实现它的类，用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现。<br>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p><p>#Overload和Override的区别#<br>Overload是一个类中定义了多个同名方法，它们有不同的参数个数或者有不同的参数类型，Overload的方法是可以改变返回值的类型。Override是方法的重写，子类中定义某方法与父类中有相同名称和参数。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。</p><p>#JAVA面向对象的特征#<br>抽象、继承、封装、多态。</p><p>#Comparable和Comparator接口区别<br>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，输入对象小于，等于，大于已经存在的对象则分别返回负数，0，正数。<br>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p><p>#类加载机制，双亲委派模型#<br>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p><p>#String为什么不可变#<br>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用github搭建自己的博客</title>
      <link href="/2019/05/15/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/05/15/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h1><ol><li>安装<a href="http://https://nodejs.org/en/" title="nodejs下载地址" target="_blank" rel="noopener">node.js</a>。</li><li>安装<a href="http://https://gitforwindows.org/" title="git下载地址" target="_blank" rel="noopener">GitForWindows</a>，没有的同学在这一部还要注册<a href="http://https://github.com/" title="github官网" target="_blank" rel="noopener">github</a>。<br><img src="/2019/05/15/利用github搭建自己的博客/1.png" alt></li><li>安装Hexo。打开命令终端，输入<code>npm install -g hexo-cli</code>安装，安装完成后，检查是否成功<code>hexo version</code>。<br><img src="/2019/05/15/利用github搭建自己的博客/2.png" alt></li><li>使用hexo初始化一个项目，选择一个文件夹，用来存放博客项目。<br><img src="/2019/05/15/利用github搭建自己的博客/3.png" alt><br>之后会弹出一个git命令窗口，输入<code>hexo init 你自己的项目名称</code>（我的是MyBlog），运行结束后会出现自己的项目文件夹，然后输入<code>cd 你自己的项目名称</code>进入到该项目文件目录下，最后输入<code>npm install</code>命令。<a id="more"></a><h1 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h1></li><li>在上述git窗口继续执行命令<code>hexo g</code>，以后每次更新博客都需要执行此命令。<br><img src="/2019/05/15/利用github搭建自己的博客/4.png" alt></li><li>接下来执行<code>hexo s</code>，打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>查看结果。<br><img src="/2019/05/15/利用github搭建自己的博客/5.png" alt></li><li>页面可以访问，并且显示首页，博客项目就已经创建好了。<br><img src="/2019/05/15/利用github搭建自己的博客/6.png" alt><h1 id="3-部署到github"><a href="#3-部署到github" class="headerlink" title="3.部署到github"></a>3.部署到github</h1></li><li>登陆github账号创建一个新的仓库。<br><img src="/2019/05/15/利用github搭建自己的博客/7.png" alt></li><li>创建格式必须为用户名.github.io。<br><img src="/2019/05/15/利用github搭建自己的博客/8.png" alt></li><li>创建好以后进入设置界面，滑动到仓库设置界面的最底部，找到“GitHub Pages”选项，点击“Choose a theme”。<br><img src="/2019/05/15/利用github搭建自己的博客/9.png" alt></li><li>选择一个主题，应用即可，这里用Chrome浏览器设置，其他浏览器可能还会有问题。</li><li>在git窗口执行命令<code>ssh-keygen</code>,一路回车确定，执行完毕后，会在 “ c://Users/用户名/.ssh 文件夹下 ”生成两个文件，分别是： id_rsa 和 id_rsa.pub。</li><li>用记事本打开 idrsa.pub 文件，复制里面的所有内容。打开 github，点击设置，进入SSH and GPG keys页面。点击 NEW SSH key 进入SSH key添加界面。其中：title任意填，key填入刚刚我们复制的id_rsa.pub的内容，最后点击 Add SSH key 完成添加。<br><img src="/2019/05/15/利用github搭建自己的博客/10.png" alt></li><li>进入项目文件夹，找到“ _config.yml ” 配置文件，在文件最后找到deploy,修改代码。(注意，冒号后面要加空格)<pre class="prettyprint lang-javascript">deploy:type: git  repo: git@github.com:ShuguangYangshugangyang.github.io.git  branch: master</pre>  </li><li>在gitbash命令终端，执行命令<code>hexo d -g</code>,提示输入密码的话，直接回车。</li><li>最后访问网址：https://你的GitHub用户名.github.io 就可以看到我们的网址啦！</li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的垃圾回收机制</title>
      <link href="/2019/04/15/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/04/15/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的垃圾回收机制"><a href="#Java的垃圾回收机制" class="headerlink" title="Java的垃圾回收机制"></a>Java的垃圾回收机制</h1><ol><li>Java的垃圾回收机制，使得Java程序员在编写程序的时候不再考虑内存管理。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡或者长时间没有使用的对象进行清除和回收。</li><li>垃圾回收涉及到两种做法：引用计数法和可达性分析算法。这里还涉及到java的4种引用方式：强引用，软引用，弱引用和虚引用。其中引用强度越来越低，也就意味着引用弱的对象越容易被垃圾回收。<h1 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h1></li><li>Java程序内存的分配是在JVM虚拟机内存分配机制下完成，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。Java数据区域分为五大数据区域。这些区域各有各的用途，创建及销毁时间。其中方法区和堆是所有线程共享的，栈，本地方法栈和程序虚拟机则为线程私有的。程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。<br><img src="/2019/04/15/Java的垃圾回收机制/1.png" alt></li><li>Java利用多线程机制使得多个任务能够同时执行处理，所有的线程共享JVM内存区域，而且每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理。<h1 id="分代的垃圾回收策略"><a href="#分代的垃圾回收策略" class="headerlink" title="分代的垃圾回收策略"></a>分代的垃圾回收策略</h1></li><li>新生代（Young Generation）。所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集那些生命周期短的对象。新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。NewSize和MaxNewSize分别可以控制新生代的初始大小和最大的大小。</li><li>老年代（Old Generation）。在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</li><li>持久代（Permanent Generation）。用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。<br><img src="/2019/04/15/Java的垃圾回收机制/2.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启新的篇章</title>
      <link href="/2018/06/29/%E5%BC%80%E5%90%AF%E6%96%B0%E7%9A%84%E7%AF%87%E7%AB%A0/"/>
      <url>/2018/06/29/%E5%BC%80%E5%90%AF%E6%96%B0%E7%9A%84%E7%AF%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>以后要记录所有新学到的知识点<br>开启一段新的学习方法</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
            <tag> 记叙 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404</title>
      <link href="/404/index.html"/>
      <url>/404/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>search</title>
      <link href="/search/index.html"/>
      <url>/search/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>QQ： 437012461<br>微信： yang437012461<br>学校： 电子科技大学</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
